<!DOCTYPE html>
<html lang="pl">
<head>
  <meta charset="UTF-8">
  <title>3D Tetris z cieniem na dnie studni</title>
  <style>
    body { margin: 0; overflow: hidden; background: #000; }
    #ui {
      position: absolute;
      top: 10px; left: 10px;
      background: rgba(0,0,0,0.5);
      color: #fff; padding: 10px;
      z-index: 999;
      font-family: sans-serif;
    }
    #ui div { margin-bottom: 5px; }
  </style>
</head>
<body>

<div id="ui">
  <div>Score: <span id="score">0</span></div>
  <div>Level: <span id="level">1</span></div>
  <div>View: <span id="view-angle">0°</span></div>
</div>

<!-- THREE.js -->
<script src="https://cdn.jsdelivr.net/npm/three@0.147.0/build/three.min.js"></script>

<script>
/************************************************************
 * USTAWIENIA STUDNI I GRY
 ************************************************************/
const BOARD_WIDTH  = 10;  // X
const BOARD_HEIGHT = 30;  // Y
const BOARD_DEPTH  = 10;  // Z

const FALL_SPEED_BASE = 1000;
let score = 0, level = 1;
let viewAngle = 0;

const COLORS = [0xff6b6b, 0x4ecdc4, 0x45b7d1, 0x96ceb4, 0xffeead, 0xff9999];
const PIECE_TYPES = ['I','O','L','T'];

let scene, camera, renderer;
let tetris;
let fallTimer = null;

// Pozycja domyślna kamery
const CAMERA_DEFAULT_POS = new THREE.Vector3(15, 40, 25);

/************************************************************
 * KLASA SHAPE3D - KLOCEK JAKO GROUP
 ************************************************************/
class Shape3D {
  constructor(type, color) {
    this.group = new THREE.Group(); 
    scene.add(this.group);

    // Bazowa pozycja logiczna
    this.position = new THREE.Vector3(0,0,0);

    // Tworzymy sub-bloczki
    const coords = this.getShapeCoords(type);
    coords.forEach(coord => {
      const mesh = this.createBlock(color);
      // local position
      mesh.position.set(coord.x, 0, coord.z);
      this.group.add(mesh);
    });
  }

  getShapeCoords(type) {
    switch(type){
      case 'O': return [ {x:0,z:0}, {x:1,z:0}, {x:0,z:1}, {x:1,z:1} ];
      case 'I': return [ {x:0,z:0}, {x:1,z:0}, {x:2,z:0}, {x:3,z:0} ];
      case 'L': return [ {x:0,z:0}, {x:0,z:1}, {x:0,z:2}, {x:1,z:2} ];
      case 'T': return [ {x:0,z:0}, {x:1,z:0}, {x:2,z:0}, {x:1,z:1} ];
      default:  return [ {x:0,z:0} ];
    }
  }

  createBlock(color) {
    const geom = new THREE.BoxGeometry(1,1,1);
    const mat = new THREE.MeshPhongMaterial({ color });
    const mesh = new THREE.Mesh(geom, mat);
    // Ustawiamy castShadow = true, by bloczek rzucał cień
    mesh.castShadow = true;

    // Krawędzie
    const eg = new THREE.EdgesGeometry(geom);
    const ed = new THREE.LineSegments(eg, new THREE.LineBasicMaterial({ color:0xffffff }));
    mesh.add(ed);

    return mesh;
  }

  setPosition(x,y,z) {
    this.position.set(x,y,z);
    this.updateGroupTransform();
  }
  updateGroupTransform() {
    this.group.position.set(this.position.x, this.position.y, this.position.z);
  }

  // Wyliczamy globalne pozycje sub-bloczków (po rotacji group)
  getGlobalPositions3D() {
    const out = [];
    this.group.children.forEach(child => {
      const localPos = child.position.clone();
      localPos.applyQuaternion(this.group.quaternion);
      localPos.add(this.group.position);
      const gx = Math.round(localPos.x);
      const gy = Math.round(localPos.y);
      const gz = Math.round(localPos.z);
      out.push({x: gx, y: gy, z: gz});
    });
    return out;
  }

  // Obrót wokół osi X/Y/Z
  rotateAxis(axis, clockwise=true) {
    const angle = (clockwise ? -1 : 1)*(Math.PI/2);
    const oldRot = this.group.rotation.clone();
    if(axis==='x')      this.group.rotation.x += angle;
    else if(axis==='y') this.group.rotation.y += angle;
    else if(axis==='z') this.group.rotation.z += angle;
    return oldRot;
  }
}

/************************************************************
 * TETRIS3D - LOGIKA GRY
 ************************************************************/
class Tetris3D {
  constructor() {
    // Tablica 3D [x][y][z]
    this.grid = Array.from({length: BOARD_WIDTH}, ()=>
      Array.from({length: BOARD_HEIGHT},()=>
        Array.from({length: BOARD_DEPTH}, ()=>null)
      )
    );
    this.currentPiece = null;

    this.initSceneHelpers();
    this.initKeyboard();
    this.spawnPiece();
    this.startFalling();
  }

  initSceneHelpers() {
    // 1) Podłoga - plane geometry, receiveShadow = true
    const planeGeom = new THREE.PlaneGeometry(BOARD_WIDTH, BOARD_DEPTH);
    const planeMat = new THREE.MeshPhongMaterial({ color: 0x222222 });
    const bottomPlane = new THREE.Mesh(planeGeom, planeMat);
    bottomPlane.receiveShadow = true; // żeby cień był widoczny
    bottomPlane.rotation.x = -Math.PI/2;
    bottomPlane.position.set(BOARD_WIDTH/2, 0, BOARD_DEPTH/2);
    scene.add(bottomPlane);

    // 2) Krawędzie boxa (bez pełnych ścian, by światło mogło wpaść)
    const boxGeom = new THREE.BoxGeometry(BOARD_WIDTH, BOARD_HEIGHT, BOARD_DEPTH);
    const edgesGeom = new THREE.EdgesGeometry(boxGeom);
    const edges = new THREE.LineSegments(edgesGeom, new THREE.LineBasicMaterial({ color:0x999999 }));
    edges.position.set(BOARD_WIDTH/2, BOARD_HEIGHT/2, BOARD_DEPTH/2);
    scene.add(edges);
  }

  initKeyboard() {
    document.addEventListener('keydown', e => {
      switch(e.key){
        // Ruch relatywny do kamery
        case 'ArrowUp':
          this.movePieceRelative(1, false); 
          break;
        case 'ArrowDown':
          this.movePieceRelative(-1, false);
          break;
        case 'ArrowLeft':
          this.movePieceRelative(1, true);
          break;
        case 'ArrowRight':
          this.movePieceRelative(-1, true);
          break;

        // Soft/Hard drop
        case 'Shift': this.softDrop(); break;
        case ' ':     this.hardDrop(); break;

        // Rotacje 3D
        case 'w': this.rotatePiece('x', true); break;
        case 's': this.rotatePiece('x', false);break;
        case 'a': this.rotatePiece('y', false);break;
        case 'd': this.rotatePiece('y', true); break;
        case 'q': this.rotatePiece('z', false);break;
        case 'e': this.rotatePiece('z', true); break;

        // Widok
        case 'Enter': this.rotateView(); break;
        case 'c':
        case 'C':
          this.resetCameraView();
          break;
      }
    });
  }

  movePieceRelative(direction, sideways) {
    // Wektor "forward" kamery, ignorujemy Y
    const forward = new THREE.Vector3();
    camera.getWorldDirection(forward);
    forward.y=0; forward.normalize();

    // Wektor "right" = forward x (0,1,0)
    const up = new THREE.Vector3(0,1,0);
    const right = forward.clone().cross(up).normalize();

    let movement = new THREE.Vector3();
    if(sideways){
      // lewo/prawo
      movement.copy(right).multiplyScalar(-direction);
    } else {
      // przód/tył
      movement.copy(forward).multiplyScalar(direction);
    }
    movement.y=0;

    const {x,y,z} = this.currentPiece.position;
    let nx = x + Math.round(movement.x);
    let nz = z + Math.round(movement.z);

    if (this.canPlace(this.currentPiece, nx, y, nz)) {
      this.currentPiece.setPosition(nx, y, nz);
    }
  }

  spawnPiece() {
    const t = PIECE_TYPES[Math.floor(Math.random()*PIECE_TYPES.length)];
    const c = COLORS[Math.floor(Math.random()*COLORS.length)];
    this.currentPiece = new Shape3D(t, c);

    const sx = Math.floor(BOARD_WIDTH/2)-1;
    const sy = BOARD_HEIGHT-2;
    const sz = Math.floor(BOARD_DEPTH/2)-1;
    this.currentPiece.setPosition(sx, sy, sz);

    if(!this.canPlace(this.currentPiece, sx,sy,sz)){
      alert("Game Over! Score: "+score);
      this.resetGame();
    }
  }

  startFalling() {
    const spd = FALL_SPEED_BASE / level;
    fallTimer = setInterval(()=>this.softDrop(), spd);
  }
  stopFalling() {
    clearInterval(fallTimer);
    fallTimer=null;
  }

  softDrop() {
    const {x,y,z} = this.currentPiece.position;
    if (this.canPlace(this.currentPiece, x, y-1, z)){
      this.currentPiece.setPosition(x,y-1,z);
    } else {
      this.lockPiece();
    }
  }

  hardDrop() {
    let {x,y,z} = this.currentPiece.position;
    while(this.canPlace(this.currentPiece, x,y-1,z)){
      y--;
    }
    this.currentPiece.setPosition(x,y,z);
    this.lockPiece();
  }

  rotatePiece(axis, clockwise){
    const oldRot = this.currentPiece.rotateAxis(axis, clockwise);
    // Sprawdzamy kolizję
    const blocks = this.currentPiece.getGlobalPositions3D();
    let valid=true;
    for(let p of blocks){
      if(!this.isValidCoord(p.x,p.y,p.z) || this.grid[p.x][p.y][p.z]){
        valid=false; break;
      }
    }
    if(!valid){
      this.currentPiece.group.rotation.copy(oldRot);
    }
  }

  lockPiece() {
    this.stopFalling();
    const blocks = this.currentPiece.getGlobalPositions3D();
    blocks.forEach(p=>{
      this.grid[p.x][p.y][p.z] = this.currentPiece;
    });
    this.checkFullLayers();
    this.spawnPiece();
    this.startFalling();
  }

  checkFullLayers() {
    let layersCleared=0;
    for(let y=0; y<BOARD_HEIGHT; y++){
      if(this.isLayerFull(y)){
        this.clearLayer(y);
        layersCleared++;
      }
    }
    if(layersCleared>0){
      score += layersCleared * BOARD_WIDTH * 100;
      document.getElementById('score').textContent = score;
      this.updateLevel();
    }
  }
  isLayerFull(ly){
    for(let x=0; x<BOARD_WIDTH; x++){
      for(let z=0; z<BOARD_DEPTH; z++){
        if(!this.grid[x][ly][z]) return false;
      }
    }
    return true;
  }
  clearLayer(ly){
    // usuwamy
    for(let x=0;x<BOARD_WIDTH;x++){
      for(let z=0;z<BOARD_DEPTH;z++){
        let shape = this.grid[x][ly][z];
        if(shape){
          scene.remove(shape.group);
          this.grid[x][ly][z] = null;
        }
      }
    }
    // przesuwamy
    for(let y=ly; y<BOARD_HEIGHT-1; y++){
      for(let x=0; x<BOARD_WIDTH; x++){
        for(let z=0; z<BOARD_DEPTH; z++){
          this.grid[x][y][z] = this.grid[x][y+1][z];
          this.grid[x][y+1][z] = null;
        }
      }
    }
    this.rebuildScene();
  }

  rebuildScene() {
    // usuwamy ze sceny
    for(let x=0;x<BOARD_WIDTH;x++){
      for(let y=0;y<BOARD_HEIGHT;y++){
        for(let z=0;z<BOARD_DEPTH;z++){
          if(this.grid[x][y][z]){
            scene.remove(this.grid[x][y][z].group);
          }
        }
      }
    }
    // budujemy ponownie
    const shapeMap = new Map();
    for(let x=0;x<BOARD_WIDTH;x++){
      for(let y=0;y<BOARD_HEIGHT;y++){
        for(let z=0;z<BOARD_DEPTH;z++){
          const sh = this.grid[x][y][z];
          if(!sh) continue;
          if(!shapeMap.has(sh)){
            shapeMap.set(sh,[]);
          }
          shapeMap.get(sh).push({x,y,z});
        }
      }
    }
    shapeMap.forEach((positions,shape)=>{
      const newGroup = new THREE.Group();
      scene.add(newGroup);

      let color=0xffffff;
      if(shape.group.children.length>0){
        const mc = shape.group.children[0].material;
        if(mc) color=mc.color.getHex();
      }
      let minX=Infinity, minY=Infinity, minZ=Infinity;
      positions.forEach(p=>{
        if(p.x<minX) minX=p.x;
        if(p.y<minY) minY=p.y;
        if(p.z<minZ) minZ=p.z;
      });
      positions.forEach(p=>{
        const geom = new THREE.BoxGeometry(1,1,1);
        const mat = new THREE.MeshPhongMaterial({color});
        const mesh = new THREE.Mesh(geom,mat);
        mesh.castShadow = true; // cień w nowej instancji
        const eg = new THREE.EdgesGeometry(geom);
        const ed = new THREE.LineSegments(eg,new THREE.LineBasicMaterial({color:0xffffff}));
        mesh.add(ed);
        mesh.position.set(p.x-minX,p.y-minY,p.z-minZ);
        newGroup.add(mesh);
      });
      newGroup.position.set(minX,minY,minZ);

      positions.forEach(p=>{
        this.grid[p.x][p.y][p.z]={ group:newGroup };
      });
    });
  }

  updateLevel() {
    level = Math.floor(score/1000)+1;
    document.getElementById('level').textContent = level;
    this.stopFalling();
    this.startFalling();
  }

  resetGame() {
    this.stopFalling();
    for(let x=0;x<BOARD_WIDTH;x++){
      for(let y=0;y<BOARD_HEIGHT;y++){
        for(let z=0;z<BOARD_DEPTH;z++){
          if(this.grid[x][y][z]){
            scene.remove(this.grid[x][y][z].group);
            this.grid[x][y][z] = null;
          }
        }
      }
    }
    score=0; level=1;
    document.getElementById('score').textContent=score;
    document.getElementById('level').textContent=level;
    this.spawnPiece();
    this.startFalling();
  }

  // Ruch kamery - obrót 90° co Enter
  rotateView(){
    viewAngle = (viewAngle+90)%360;
    const angleRad = THREE.MathUtils.degToRad(viewAngle);
    const cx= BOARD_WIDTH/2, cy=BOARD_HEIGHT/2, cz=BOARD_DEPTH/2;
    const radius=25;
    const camX = cx + radius*Math.cos(angleRad);
    const camZ = cz + radius*Math.sin(angleRad);
    camera.position.set(camX, BOARD_HEIGHT+5, camZ);
    camera.lookAt(cx,cy,cz);
    document.getElementById('view-angle').textContent=viewAngle+'°';
  }

  // Reset kamery (C)
  resetCameraView(){
    camera.position.copy(CAMERA_DEFAULT_POS);
    camera.lookAt(BOARD_WIDTH/2, BOARD_HEIGHT/2, BOARD_DEPTH/2);
    viewAngle=0;
    document.getElementById('view-angle').textContent='0°';
  }

  canPlace(shape, nx, ny, nz){
    const oldPos = shape.position.clone();
    const oldRot = shape.group.rotation.clone();

    shape.setPosition(nx,ny,nz);
    const blocks = shape.getGlobalPositions3D();
    let can=true;
    for(let p of blocks){
      if(!this.isValidCoord(p.x,p.y,p.z) || this.grid[p.x][p.y][p.z]){
        can=false; break;
      }
    }
    // cofamy
    shape.setPosition(oldPos.x,oldPos.y,oldPos.z);
    shape.group.rotation.copy(oldRot);
    return can;
  }
  isValidCoord(x,y,z){
    if(x<0||x>=BOARD_WIDTH)  return false;
    if(y<0||y>=BOARD_HEIGHT) return false;
    if(z<0||z>=BOARD_DEPTH)  return false;
    return true;
  }
}

/************************************************************
 * INICJALIZACJA THREE.JS
 ************************************************************/
function init() {
  scene = new THREE.Scene();
  scene.background = new THREE.Color(0x111111);

  // Kamera perspektywiczna
  const fov=60, aspect=window.innerWidth/window.innerHeight;
  camera = new THREE.PerspectiveCamera(fov, aspect, 0.1, 1000);
  camera.position.copy(CAMERA_DEFAULT_POS);
  camera.lookAt(BOARD_WIDTH/2, BOARD_HEIGHT/2, BOARD_DEPTH/2);

  // Renderer z włączonym cieniowaniem
  renderer = new THREE.WebGLRenderer({antialias:true});
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.shadowMap.enabled = true;        // włączamy cienie
  renderer.shadowMap.type = THREE.PCFSoftShadowMap; // miękkie cienie
  document.body.appendChild(renderer.domElement);

  // Światło kierunkowe - z góry
  const dirLight = new THREE.DirectionalLight(0xffffff,1);
  dirLight.position.set(0,50,0); // nad studnią
  dirLight.castShadow = true;    // rzuca cienie
  // Aby cień objął całą scenę, ustawiamy kamerę cieni
  const d = 30; // half-size "ortho" w cieniach
  dirLight.shadow.camera.left = -d;
  dirLight.shadow.camera.right= d;
  dirLight.shadow.camera.top  = d;
  dirLight.shadow.camera.bottom= -d;
  dirLight.shadow.camera.near=1;
  dirLight.shadow.camera.far=100;
  scene.add(dirLight);

  // Ambient light, aby nie było totalnie ciemno w środku
  const amb = new THREE.AmbientLight(0x404040);
  scene.add(amb);

  // Start gry
  tetris = new Tetris3D();
  animate();
}

function animate(){
  requestAnimationFrame(animate);
  renderer.render(scene,camera);
}

window.addEventListener('resize',()=>{
  const w=window.innerWidth, h=window.innerHeight;
  camera.aspect=w/h;
  camera.updateProjectionMatrix();
  renderer.setSize(w,h);
});

init();
</script>
</body>
</html>
